> Steering Algorithms



## Summary



## Framework

***[Game Image]***

![](/img/in-post/write-up-15/1.JPG)

* A 500x500 voxel terrain that has different kinds of cubes (land, forest, and sea). 
* Player can fly over the terrain with a first person controller. 
* Player can collect coins in the game world.
* The terrain is drawn in both triangle mode and line mode.

## Terrain System

Now I calculate all vertices according to meightmaps. There are two ways to convert every vertex into a cube. 

First is doing it in compiling time, for every vertex, I calculate all 8 vertices and 36 indices in building time. The advantage is we only need to draw one mesh when rendering. The disadvantage is the binary file is very big (56.4mb), and it isn't interactable. This method did work well. The game has good frame rate even if I added 50 more colliders. 

The other method is to draw many cubes in positions of vertices, which will have too many draw calls. In this way, every cube is an gameobject.
However, it only work while I have under 5000 cubes in OpenGL. The graphics system cannot afford so many draw calls. So I have to abandon this method.

Besides, I found a way to add border lines to cubes, which is to draw the terrain mesh twice both in triangle mode and line mode. Actualy, the best effect in my mind is to draw rectangles even if it requires me to change indices buffer. However, only old version OpenGL support draw rectangles. Direct3D doesn't even support it. Therefore, I have to draw in triangles.

In short, I did a lot of experiments and didn't change my terrain interfaces. You still don't need to add any lines of codes, just use the mesh that generated by my terrain system.

## Collision Detect System

To detect overlap and collisions, I chose to use Yitong Dai's collision system.

[EAE6320 3D Collision Response](https://yzd0014.wixsite.com/dyt1205/blog/eae6320-3d-collision-response)

The implementation of axis detection is pretty solid. Besides, It can resolve both movement collision and ritation collision perfectly. I chose to use his system to develop terrain collision in the beginning by add bounding box to each cube. However, I cannot use his AABB bounding box to my random terrain mesh. So I add coins to my game so that the player can collect them while overlapping.

## Some Other Updates

* added eular engles to rigidbody to implement first person player controller.
* reimplemented gameobject class. Added some virtual functions such as `Update()`, `EventHit()`. Camera class is derived from new gameobject class. 

## What I Learned in this Class

Honestly speaking, I learned much more than I hoped in this class. I think the most important I learned is about the engine structure. I also learned much in Joe's class in the last semester, most of which are about specific engine function. I know how to make memory allocator, how to detect collision, and how to make a job system. However, I don't know how to make an engine framework to connect them together. In this class, I got a pretty solid engine framework to learn and modify. 

The secound thing is about writing interfaces. For example, after I finished assignments about making platform independent graphics library, I did learn how to add high level classes and interfaces based on it. I made my own terrain project, gameobject class and modified rigidbody a lot.

The last thing is about C++.




